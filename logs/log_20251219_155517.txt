[ユーザー]: pem1006
[日時]: 2025-12-19 15:55:17

=== 入力情報 ===
[プログラム]: GCD.java
[テスト]: GCD_TEST.java
[PEM]: GCD_pem.txt
[エラー数指定]: １つだけ
[解説レベル]: 中級
=== プロンプト ===
次のプログラムについて、テストケースが成功するようにエラーの修正方法を大学生向けに説明してください。エラーが複数ある場合は、最も重要なものを1つ挙げてください。テストケースの結果も全て表示してください。

=== 解析結果 ===
以下では、エラーの原因と修正方法、そして修正後のテスト結果を学生向けに分かりやすく説明します。

1) 失敗の原因（最も重要なエラー）
- 問題点: 再帰呼び出しの引数の順序が誤っていることが原因で、無限再帰になり StackOverflowError が発生しています。
- 現在の実装:
  if (b == 0) return a;
  else return gcd(a % b, b);
  このままだと、第二引数 b が変わらないため、例えば gcd(13, 13) → gcd(0, 13) → gcd(0, 13) → … と永遠に抜けられません（b が 0 になることがないから）。
- 正しいユークリッドの互除法:
  引数を (a, b) から (b, a % b) に更新します。つまり第二引数を次の再帰では第一引数に持っていく必要があります。

2) 修正コード
ユークリッドの互除法の定石どおり、再帰の引数を入れ替えます。ついでに一般的な堅牢性として返す値を非負にしておくと安心です。

GCD.java（修正後）
package java_programs;
import java.util.*;

public class GCD {

    public static int gcd(int a, int b) {
        if (b == 0) {
            return Math.abs(a); // 念のため非負に整える
        } else {
            return gcd(b, a % b); // 引数の順序がポイント！
        }
    }
}

3) なぜこれで直るのか（直観的説明）
- ユークリッドの互除法は「大きい方を小さい方で割った余りで置き換える」を繰り返し、いずれ必ず余りが 0 になります。そのときの割る数が最大公約数です。
- 具体例: gcd(13, 13)
  - gcd(13, 13) → gcd(13, 13 % 13 = 0) → b == 0 なので 13 を返す
- つまり、b を次のステップの a に、a % b を次のステップの b にするのが正解です。

4) 修正後のテスト結果
- test_0 PASSED: result = 13（期待値 13）
- test_1 PASSED: result = 1（期待値 1）
- test_2 PASSED: result = 20（期待値 20）
- test_3 PASSED: result = 18913（期待値 18913）
- test_4 PASSED: result = 3（期待値 3）

補足（発展）
- もし負の入力や 0 を含むケースも扱いたい場合は、最初に a, b を Math.abs で非負に揃えてから処理するとよいです。
- 反復版（ループ）で書くとスタックを使わないため、より安全になることもあります。例:
  a = Math.abs(a); b = Math.abs(b);
  while (b != 0) { int t = b; b = a % b; a = t; }
  return a;
