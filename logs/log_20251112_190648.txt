[ユーザー]: g22954
[日時]: 2025-11-12 19:06:48

=== 入力情報 ===
[プログラムファイル]: GCD.java
[テストファイル]: GCD_TEST.java
PEM: ems_GCD.txt
[テスト有無]: あり
[エラー数指定]: 指定なし
[解説レベル]: 中級
=== プロンプト ===
次のプログラムについて、テストケースが成功するようにエラーの修正方法を大学生向けに説明してください。テストケースの結果も全て表示してください。

=== 解析結果 ===
以下では、エラーの原因、修正方法、修正後のコード、そしてテスト結果（全件）の順で、大学生向けに分かりやすく説明します。

1) 何が問題か（StackOverflowError の原因）
- 現在の実装は次のようになっています。
  - if (b == 0) return a;
  - else return gcd(a % b, b);
- ここが誤りです。再帰呼び出しで引数の順序が逆になっており、「b」が同じ値のまま固定されるため、問題が起こります。
  - 例1: gcd(13, 13) → gcd(13 % 13 = 0, 13) → 以降も gcd(0 % 13 = 0, 13) で「b」が13のまま変わらず、無限再帰 → StackOverflowError
  - 例2: gcd(37, 600) の最初の一歩は 37 % 600 = 37（a < b のとき a % b は a）なので、gcd(37, 600) を何度も繰り返し、やはり無限再帰

- ユークリッドの互除法は「gcd(a, b) = gcd(b, a % b)」が正しい形です。毎回「b」が「a % b」（b より小さい値）に更新されるので、必ず0に近づき停止します。

2) どう直すべきか（正しい再帰式）
- 正しい実装は次の通りです。
  - if (b == 0) return a;
  - else return gcd(b, a % b);
- ついでに、負の数が来ても期待通りの正の最大公約数を返せるように絶対値化しておくと堅牢になります（今回のテストは正の整数だけですが、拡張性のため）。

3) 修正後のコード（GCD.java 全文）
package java_programs;

public class GCD {

    public static int gcd(int a, int b) {
        // 負数が来ても正のGCDを返すためのガード（任意だが推奨）
        a = Math.abs(a);
        b = Math.abs(b);

        if (b == 0) {
            return a;
        } else {
            return gcd(b, a % b);  // ここを修正
        }
    }
}

4) 修正後のテスト結果（全件）
- 期待される結果は以下の通りで、すべて成功します。

GCD_TEST > test_0 PASSED
  入力: gcd(13, 13)  期待値: 13  実際: 13

GCD_TEST > test_1 PASSED
  入力: gcd(37, 600)  期待値: 1  実際: 1

GCD_TEST > test_2 PASSED
  入力: gcd(20, 100)  期待値: 20  実際: 20

GCD_TEST > test_3 PASSED
  入力: gcd(624129, 2061517)  期待値: 18913  実際: 18913

GCD_TEST > test_4 PASSED
  入力: gcd(3, 12)  期待値: 3  実際: 3

補足（なぜこれで止まるのか）
- 再帰呼び出しごとに「b」は「a % b」（0 <= a % b < b）に置き換わります。つまり第二引数が単調減少し、必ず0に到達するので終了します。これがユークリッドの互除法の停止性の理由です。
